## docker-compose.yml の env_file: と config.py について

- まず
```
env_file:
  - .env.development
```
で Docker（正確には docker-compose）が
.env.development を読み込んで
その中の値を「コンテナの環境変数」として注入する

```
.env.development
      ↓
Docker Compose が読む
      ↓
コンテナの環境変数（ENV）
      ↓
Pydantic Settings が os.getenv 経由で読む
```

- FastAPI は config.py で
```
env_mode = os.getenv("ENV", "development")
```
ここで読んでいるのはコンテナに注入された環境変数（Dockerが用意したもの）
ENV がなければデフォルトの環境変数は "development" になる

```
env_mode = os.getenv("ENV", "development")  # デフォルトは development

if env_mode == "development":
    env_file = ".env.development"
elif env_mode == "production":
    env_file = ".env.production"
elif env_mode == "test":
    env_file = ".env.test"
else:
    env_file = ".env.development" 
```

- model_config = ConfigDict(env_file=env_file) の意味

```
model_config = ConfigDict(
    env_file=env_file,
    env_file_encoding="utf-8",
)

```
これは Docker を使わない場合でも Python 単体で .env.xxx を直接読むための保険

つまり Settings は：

**1. まず OS の環境変数を見る**

**2. 足りなければ env_file を読む**

という動き

- なぜ docker-compose と Pydantic の両方で env_file がある？

役割	                        読む人	      目的
docker-compose の env_file	    Docker	     コンテナの ENV を作る
Pydantic の env_file	        Python	     ローカル実行 / pytest 用

二重管理ではなく「責務が違う」

よくある誤解（ここ重要）

❌ docker-compose の env_file を書いたら
→ Python が勝手に .env を読む

⭕ 実際は：

Dockerが読む

Pythonは 環境変数として受け取るだけ

.env を直接読むかどうかは Python 側の設定次第